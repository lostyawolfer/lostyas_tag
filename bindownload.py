#!/usr/bin/env python3

"""
Downloads assets required for running server from
remote urls, as provided by the spec file.
"""

import argparse
import hashlib
import logging
import pathlib as pth
import shutil
import sys
import tomllib as toml
from urllib import request

DEFAULTS = {
    'spec': 'versions.toml',
    'loglevel': 'INFO',
    'rootdir': '.'
}

log = logging.getLogger(__name__)
# TODO: Set custom logging format for INFO level
logging.basicConfig(level=logging.ERROR)

class DLError(Exception):
    pass


def human_size(size):
    for x in 'bytes', 'KiB', 'MiB', 'GiB', 'TiB':
        if size < 1024.0:
            break
        size /= 1024
    return (f'{size:.1f}' if x != 'bytes' else f'{size}') + f' {x}'


def load_spec(filename):
    with open(filename, 'rb') as file:
        return toml.load(file)

def spec_targets(parsed_spec):
    """Get target names out of parsed spec."""
    return list(parsed_spec)

def download(parsed_spec, target_name, rootdir):
    """
    reads parsed spec (as returned by `load_spec`),
    reads url of the target name (given as [mytarget] in TOML),
    and downloads file from this url to outdir
    """
    # ensure outdir is convertable to Path
    outdir = pth.Path(rootdir)    

    target = parsed_spec[target_name]
    url = target['url']
    log.debug(f'Parsed url for "{target_name}":' +
              f' "{url}"')

    subdir = target.get('subdir', '.')
    outdir = outdir.joinpath(subdir)
    outdir.mkdir(exist_ok=True)
    assert outdir.is_dir()
    
    reqobj = request.Request(url, headers={
        # imitate CURL
        'User-Agent': 'curl/8.11.0'
    })
    req = request.urlopen(reqobj)               # open url as file-like

    # Construct file name
    fmt = target.get('name_format')
    log.debug(f'Fmt is "{fmt}"')
    if fmt:             # Try from format
        filename = fmt.format(**target)
        log.debug(f'Constructed filename "{filename}"')
    else:               # Or use from server
        filename = req.headers.get_filename()    # get filename as provided by server
        # sanitize filename to avoid injections
        filename = pth.Path(filename).name
        log.debug(f'Got filename from server "{filename}"')

    # construct file path from two parts
    outname = outdir.joinpath(filename)
    log.debug(f'Constructed out filename "{outname}"')
    
    # finally download it
    with open(outname, 'wb') as outfile:
        # same as
        # outfile.write(req.read())
        shutil.copyfileobj(req, outfile)
        size = outfile.tell()       # returns bytes written
        log.debug(f'Downloaded {outname} ({human_size(size)})')
    
    hash = target.get('hash')        # will resort to None if not provided
    if hash and not verify_hash(hash, open(outname, 'rb')):
        raise DLError(f'Hash check failure. Expected {hash}')

    return size


def verify_hash(hashdescr, fileobj):
    algo, hash_in = hashdescr.split(':', 1)
    algo = algo.lower()
    h = hashlib.file_digest(fileobj, algo)
    digest = h.hexdigest()
    log.debug(f'Computed hash: {digest}')

    return digest == hash_in


def parse_args(argv=sys.argv):
    """Use argparse to get arguments."""
    # ref: https://docs.python.org/3/library/argparse.html

    progname, *args = argv
    progname = pth.Path(progname).name      # or .stem to have .py stripped

    description = __doc__       # use module own docstring for description

    parser = argparse.ArgumentParser(
        prog=progname,
        description=description,
        usage=None,      # auto-generated by default
        epilog=None,     # Text at the bottom of help
        )

    parser.add_argument('-v', '--verbose',
        default=0, action='count',
        help='verbosity level. Can be combined, i.e. -vvvvv')

    parser.add_argument('-l', '--list-targets',
        action='store_true',
        help='list available targets and exit')

    parser.add_argument('-s', '--spec',
        dest='specfile', metavar='SPECFILE.toml',
        type=pth.Path, default=DEFAULTS['spec'],
        help='path to a spec file in TOML format')
    
    parser.add_argument('--out-dir',
        dest='rootdir', metavar='OUTDIR',
        type=pth.Path, default=DEFAULTS['rootdir'],
        help='output root directory for downloads')
    
    parser.add_argument('targets',
        nargs='*', metavar='..TARGETS',
        default=['ALL'],
        help='Targets to be downloaded (or ALL)')
    
    parsed = parser.parse_args(args)
    assert parsed.specfile.is_file()
    return vars(parsed)

def set_loglevel(logobj, nverbose, *,
                 available_names=('info', 'warning', 'error', 'debug'),
                 default=DEFAULTS['loglevel']):
    available_names = list(available_names)
    try:
        level_name = available_names[nverbose]
    except IndexError:
        level_name = available_names[-1]
    # level = getattr(log, level.upper())     # transform
    levels = logging.getLevelNamesMapping()
    selected = levels.get(level_name.upper(), default.upper())
    logobj.setLevel(selected)  
    

if __name__ == '__main__':
    parsed = parse_args()
    # Set provided logging verbosity
    nverbose = parsed['verbose']
    set_loglevel(log, nverbose)
    log.debug(f'Log level is {log.level}')

    log.debug(f'Parsed args:\n{parsed}')

    spec = load_spec(parsed['specfile'])
    log.debug(f'Got spec:\n{spec}')

    if parsed['list_targets'] is True:
        targets = spec_targets(spec)
        targets = '\n\t'.join(targets)
        print('Available targets:', targets, sep='\n\t')
        exit(0)     # inversion of control

    rootdir = parsed['rootdir']
    rootdir.mkdir(exist_ok=True)            # create output dir if not exists

    targets = parsed['targets']
    if 'ALL' in targets:
        targets = spec_targets(spec)
    log.info(f'Using targets: {" ".join(targets)}')

    for target in targets:
        size = download(spec, target, rootdir)
        log.info(f'Got {target}\t{human_size(size)}')